{"meta":{"title":"Bob的个人博客","subtitle":"用代码衡量时间长度，用技术实现自我价值","description":"90后帅哥一枚，3年多iOS开发经验，坐标深圳，欢迎热爱技术的同行一起学习，一起进步","author":"陶冬波","url":"http://taodongbo.cn"},"pages":[{"title":"分类","date":"2017-10-12T07:09:50.000Z","updated":"2017-10-15T03:05:22.000Z","comments":true,"path":"categories/index.html","permalink":"http://taodongbo.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-10-12T07:51:56.000Z","updated":"2017-10-15T03:12:32.000Z","comments":true,"path":"about/index.html","permalink":"http://taodongbo.cn/about/index.html","excerpt":"","text":"关于我来自湖南永州，2014年毕业于湘潭大学。坐标深圳，职位：iOS开发，工作经验：3年半。 From 深圳 QQ：785429438Email: taodongboemail@163.com"},{"title":"标签","date":"2017-10-12T07:48:42.000Z","updated":"2017-10-15T03:05:59.000Z","comments":true,"path":"tags/index.html","permalink":"http://taodongbo.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"GCD详解","date":"2017-11-20T08:17:15.000Z","updated":"2017-11-21T03:06:30.000Z","comments":true,"path":"2017/11/20/GCD详解/","link":"","permalink":"http://taodongbo.cn/2017/11/20/GCD详解/","excerpt":"","text":"&lt;!DOCTYPE html&gt; GCD详解 .markdown-preview:not([data-use-github-style]) { padding: 2em; font-size: 1.2em; color: rgb(171, 178, 191); background-color: rgb(40, 44, 52); overflow: auto; }.markdown-preview:not([data-use-github-style]) &gt; :first-child { margin-top: 0px; }.markdown-preview:not([data-use-github-style]) h1, .markdown-preview:not([data-use-github-style]) h2, .markdown-preview:not([data-use-github-style]) h3, .markdown-preview:not([data-use-github-style]) h4, .markdown-preview:not([data-use-github-style]) h5, .markdown-preview:not([data-use-github-style]) h6 { line-height: 1.2; margin-top: 1.5em; margin-bottom: 0.5em; color: rgb(255, 255, 255); }.markdown-preview:not([data-use-github-style]) h1 { font-size: 2.4em; font-weight: 300; }.markdown-preview:not([data-use-github-style]) h2 { font-size: 1.8em; font-weight: 400; }.markdown-preview:not([data-use-github-style]) h3 { font-size: 1.5em; font-weight: 500; }.markdown-preview:not([data-use-github-style]) h4 { font-size: 1.2em; font-weight: 600; }.markdown-preview:not([data-use-github-style]) h5 { font-size: 1.1em; font-weight: 600; }.markdown-preview:not([data-use-github-style]) h6 { font-size: 1em; font-weight: 600; }.markdown-preview:not([data-use-github-style]) strong { color: rgb(255, 255, 255); }.markdown-preview:not([data-use-github-style]) del { color: rgb(124, 135, 156); }.markdown-preview:not([data-use-github-style]) a, .markdown-preview:not([data-use-github-style]) a code { color: rgb(82, 139, 255); }.markdown-preview:not([data-use-github-style]) img { max-width: 100%; }.markdown-preview:not([data-use-github-style]) &gt; p { margin-top: 0px; margin-bottom: 1.5em; }.markdown-preview:not([data-use-github-style]) &gt; ul, .markdown-preview:not([data-use-github-style]) &gt; ol { margin-bottom: 1.5em; }.markdown-preview:not([data-use-github-style]) blockquote { margin: 1.5em 0px; font-size: inherit; color: rgb(124, 135, 156); border-color: rgb(75, 83, 98); border-width: 4px; }.markdown-preview:not([data-use-github-style]) hr { margin: 3em 0px; border-top: 2px dashed rgb(75, 83, 98); background: none; }.markdown-preview:not([data-use-github-style]) table { margin: 1.5em 0px; }.markdown-preview:not([data-use-github-style]) th { color: rgb(255, 255, 255); }.markdown-preview:not([data-use-github-style]) th, .markdown-preview:not([data-use-github-style]) td { padding: 0.66em 1em; border: 1px solid rgb(75, 83, 98); }.markdown-preview:not([data-use-github-style]) code { color: rgb(255, 255, 255); background-color: rgb(58, 63, 75); }.markdown-preview:not([data-use-github-style]) pre.editor-colors { margin: 1.5em 0px; padding: 1em; font-size: 0.92em; border-radius: 3px; background-color: rgb(49, 54, 63); }.markdown-preview:not([data-use-github-style]) kbd { color: rgb(255, 255, 255); border-width: 1px 1px 2px; border-style: solid; border-color: rgb(75, 83, 98) rgb(75, 83, 98) rgb(62, 68, 81); border-image: initial; background-color: rgb(58, 63, 75); }.markdown-preview[data-use-github-style] { font-family: “Helvetica Neue”, Helvetica, “Segoe UI”, Arial, freesans, sans-serif; line-height: 1.6; word-wrap: break-word; padding: 30px; font-size: 16px; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); overflow: scroll; }.markdown-preview[data-use-github-style] &gt; :first-child { margin-top: 0px !important; }.markdown-preview[data-use-github-style] &gt; :last-child { margin-bottom: 0px !important; }.markdown-preview[data-use-github-style] a:not([href]) { color: inherit; text-decoration: none; }.markdown-preview[data-use-github-style] .absent { color: rgb(204, 0, 0); }.markdown-preview[data-use-github-style] .anchor { position: absolute; top: 0px; left: 0px; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; }.markdown-preview[data-use-github-style] .anchor:focus { outline: none; }.markdown-preview[data-use-github-style] h1, .markdown-preview[data-use-github-style] h2, .markdown-preview[data-use-github-style] h3, .markdown-preview[data-use-github-style] h4, .markdown-preview[data-use-github-style] h5, .markdown-preview[data-use-github-style] h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; }.markdown-preview[data-use-github-style] h1 .octicon-link, .markdown-preview[data-use-github-style] h2 .octicon-link, .markdown-preview[data-use-github-style] h3 .octicon-link, .markdown-preview[data-use-github-style] h4 .octicon-link, .markdown-preview[data-use-github-style] h5 .octicon-link, .markdown-preview[data-use-github-style] h6 .octicon-link { display: none; color: rgb(0, 0, 0); vertical-align: middle; }.markdown-preview[data-use-github-style] h1:hover .anchor, .markdown-preview[data-use-github-style] h2:hover .anchor, .markdown-preview[data-use-github-style] h3:hover .anchor, .markdown-preview[data-use-github-style] h4:hover .anchor, .markdown-preview[data-use-github-style] h5:hover .anchor, .markdown-preview[data-use-github-style] h6:hover .anchor { padding-left: 8px; margin-left: -30px; text-decoration: none; }.markdown-preview[data-use-github-style] h1:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h2:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h3:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h4:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h5:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h6:hover .anchor .octicon-link { display: inline-block; }.markdown-preview[data-use-github-style] h1 tt, .markdown-preview[data-use-github-style] h2 tt, .markdown-preview[data-use-github-style] h3 tt, .markdown-preview[data-use-github-style] h4 tt, .markdown-preview[data-use-github-style] h5 tt, .markdown-preview[data-use-github-style] h6 tt, .markdown-preview[data-use-github-style] h1 code, .markdown-preview[data-use-github-style] h2 code, .markdown-preview[data-use-github-style] h3 code, .markdown-preview[data-use-github-style] h4 code, .markdown-preview[data-use-github-style] h5 code, .markdown-preview[data-use-github-style] h6 code { font-size: inherit; }.markdown-preview[data-use-github-style] h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }.markdown-preview[data-use-github-style] h1 .anchor { line-height: 1; }.markdown-preview[data-use-github-style] h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }.markdown-preview[data-use-github-style] h2 .anchor { line-height: 1; }.markdown-preview[data-use-github-style] h3 { font-size: 1.5em; line-height: 1.43; }.markdown-preview[data-use-github-style] h3 .anchor { line-height: 1.2; }.markdown-preview[data-use-github-style] h4 { font-size: 1.25em; }.markdown-preview[data-use-github-style] h4 .anchor { line-height: 1.2; }.markdown-preview[data-use-github-style] h5 { font-size: 1em; }.markdown-preview[data-use-github-style] h5 .anchor { line-height: 1.1; }.markdown-preview[data-use-github-style] h6 { font-size: 1em; color: rgb(119, 119, 119); }.markdown-preview[data-use-github-style] h6 .anchor { line-height: 1.1; }.markdown-preview[data-use-github-style] p, .markdown-preview[data-use-github-style] blockquote, .markdown-preview[data-use-github-style] ul, .markdown-preview[data-use-github-style] ol, .markdown-preview[data-use-github-style] dl, .markdown-preview[data-use-github-style] table, .markdown-preview[data-use-github-style] pre { margin-top: 0px; margin-bottom: 16px; }.markdown-preview[data-use-github-style] hr { height: 4px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; }.markdown-preview[data-use-github-style] ul, .markdown-preview[data-use-github-style] ol { padding-left: 2em; }.markdown-preview[data-use-github-style] ul.no-list, .markdown-preview[data-use-github-style] ol.no-list { padding: 0px; list-style-type: none; }.markdown-preview[data-use-github-style] ul ul, .markdown-preview[data-use-github-style] ul ol, .markdown-preview[data-use-github-style] ol ol, .markdown-preview[data-use-github-style] ol ul { margin-top: 0px; margin-bottom: 0px; }.markdown-preview[data-use-github-style] li &gt; p { margin-top: 16px; }.markdown-preview[data-use-github-style] dl { padding: 0px; }.markdown-preview[data-use-github-style] dl dt { padding: 0px; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; }.markdown-preview[data-use-github-style] dl dd { padding: 0px 16px; margin-bottom: 16px; }.markdown-preview[data-use-github-style] blockquote { padding: 0px 15px; color: rgb(119, 119, 119); border-left: 4px solid rgb(221, 221, 221); }.markdown-preview[data-use-github-style] blockquote &gt; :first-child { margin-top: 0px; }.markdown-preview[data-use-github-style] blockquote &gt; :last-child { margin-bottom: 0px; }.markdown-preview[data-use-github-style] table { display: block; width: 100%; overflow: auto; word-break: keep-all; }.markdown-preview[data-use-github-style] table th { font-weight: bold; }.markdown-preview[data-use-github-style] table th, .markdown-preview[data-use-github-style] table td { padding: 6px 13px; border: 1px solid rgb(221, 221, 221); }.markdown-preview[data-use-github-style] table tr { background-color: rgb(255, 255, 255); border-top: 1px solid rgb(204, 204, 204); }.markdown-preview[data-use-github-style] table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }.markdown-preview[data-use-github-style] img { max-width: 100%; box-sizing: border-box; }.markdown-preview[data-use-github-style] .emoji { max-width: none; }.markdown-preview[data-use-github-style] span.frame { display: block; overflow: hidden; }.markdown-preview[data-use-github-style] span.frame &gt; span { display: block; float: left; width: auto; padding: 7px; margin: 13px 0px 0px; overflow: hidden; border: 1px solid rgb(221, 221, 221); }.markdown-preview[data-use-github-style] span.frame span img { display: block; float: left; }.markdown-preview[data-use-github-style] span.frame span span { display: block; padding: 5px 0px 0px; clear: both; color: rgb(51, 51, 51); }.markdown-preview[data-use-github-style] span.align-center { display: block; overflow: hidden; clear: both; }.markdown-preview[data-use-github-style] span.align-center &gt; span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: center; }.markdown-preview[data-use-github-style] span.align-center span img { margin: 0px auto; text-align: center; }.markdown-preview[data-use-github-style] span.align-right { display: block; overflow: hidden; clear: both; }.markdown-preview[data-use-github-style] span.align-right &gt; span { display: block; margin: 13px 0px 0px; overflow: hidden; text-align: right; }.markdown-preview[data-use-github-style] span.align-right span img { margin: 0px; text-align: right; }.markdown-preview[data-use-github-style] span.float-left { display: block; float: left; margin-right: 13px; overflow: hidden; }.markdown-preview[data-use-github-style] span.float-left span { margin: 13px 0px 0px; }.markdown-preview[data-use-github-style] span.float-right { display: block; float: right; margin-left: 13px; overflow: hidden; }.markdown-preview[data-use-github-style] span.float-right &gt; span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: right; }.markdown-preview[data-use-github-style] code, .markdown-preview[data-use-github-style] tt { padding: 0.2em 0px; margin: 0px; font-size: 85%; background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; }.markdown-preview[data-use-github-style] code::before, .markdown-preview[data-use-github-style] tt::before, .markdown-preview[data-use-github-style] code::after, .markdown-preview[data-use-github-style] tt::after { letter-spacing: -0.2em; content: “ “; }.markdown-preview[data-use-github-style] code br, .markdown-preview[data-use-github-style] tt br { display: none; }.markdown-preview[data-use-github-style] del code { text-decoration: inherit; }.markdown-preview[data-use-github-style] pre &gt; code { padding: 0px; margin: 0px; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0px; }.markdown-preview[data-use-github-style] .highlight { margin-bottom: 16px; }.markdown-preview[data-use-github-style] .highlight pre, .markdown-preview[data-use-github-style] pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border-radius: 3px; }.markdown-preview[data-use-github-style] .highlight pre { margin-bottom: 0px; word-break: normal; }.markdown-preview[data-use-github-style] pre { word-wrap: normal; }.markdown-preview[data-use-github-style] pre code, .markdown-preview[data-use-github-style] pre tt { display: inline; max-width: initial; padding: 0px; margin: 0px; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0px; }.markdown-preview[data-use-github-style] pre code::before, .markdown-preview[data-use-github-style] pre tt::before, .markdown-preview[data-use-github-style] pre code::after, .markdown-preview[data-use-github-style] pre tt::after { content: normal; }.markdown-preview[data-use-github-style] kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: rgb(85, 85, 85); vertical-align: middle; background-color: rgb(252, 252, 252); border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204) rgb(204, 204, 204) rgb(187, 187, 187); border-image: initial; border-radius: 3px; box-shadow: rgb(187, 187, 187) 0px -1px 0px inset; }.markdown-preview[data-use-github-style] a { color: rgb(51, 122, 183); }.markdown-preview[data-use-github-style] code { color: inherit; }.markdown-preview[data-use-github-style] pre.editor-colors { padding: 0.8em 1em; margin-bottom: 1em; font-size: 0.85em; border-radius: 4px; overflow: auto; }.scrollbars-visible-always .markdown-preview pre.editor-colors .vertical-scrollbar, .scrollbars-visible-always .markdown-preview pre.editor-colors .horizontal-scrollbar { visibility: hidden; }.scrollbars-visible-always .markdown-preview pre.editor-colors:hover .vertical-scrollbar, .scrollbars-visible-always .markdown-preview pre.editor-colors:hover .horizontal-scrollbar { visibility: visible; }.markdown-preview .task-list-item-checkbox { position: absolute; margin: 0.25em 0px 0px -1.4em; }.markdown-preview code { text-shadow: none; }.bracket-matcher .region { border-bottom: 1px dotted lime; position: absolute;}.spell-check-misspelling .region { border-bottom: 2px dotted rgba(255, 51, 51, 0.75);}.spell-check-corrections { width: 25em !important;}pre.editor-colors { background-color: #282c34; color: #abb2bf;}pre.editor-colors .line.cursor-line { background-color: rgba(153, 187, 255, 0.04);}pre.editor-colors .invisible { color: #abb2bf;}pre.editor-colors .cursor { border-left: 2px solid #528bff;}pre.editor-colors .selection .region { background-color: #3e4451;}pre.editor-colors .bracket-matcher .region { border-bottom: 1px solid #528bff; box-sizing: border-box;}pre.editor-colors .invisible-character { color: rgba(171, 178, 191, 0.15);}pre.editor-colors .indent-guide { color: rgba(171, 178, 191, 0.15);}pre.editor-colors .wrap-guide { background-color: rgba(171, 178, 191, 0.15);}pre.editor-colors .find-result .region.region.region,pre.editor-colors .current-result .region.region.region { border-radius: 2px; background-color: rgba(82, 139, 255, 0.24); transition: border-color 0.4s;}pre.editor-colors .find-result .region.region.region { border: 2px solid transparent;}pre.editor-colors .current-result .region.region.region { border: 2px solid #528bff; transition-duration: .1s;}pre.editor-colors .gutter .line-number { color: #636d83; -webkit-font-smoothing: antialiased;}pre.editor-colors .gutter .line-number.cursor-line { color: #abb2bf; background-color: #2c313a;}pre.editor-colors .gutter .line-number.cursor-line-no-selection { background-color: transparent;}pre.editor-colors .gutter .line-number .icon-right { color: #abb2bf;}pre.editor-colors .gutter:not(.git-diff-icon) .line-number.git-line-removed.git-line-removed::before { bottom: -3px;}pre.editor-colors .gutter:not(.git-diff-icon) .line-number.git-line-removed::after { content: “”; position: absolute; left: 0px; bottom: 0px; width: 25px; border-bottom: 1px dotted rgba(224, 82, 82, 0.5); pointer-events: none;}pre.editor-colors .gutter .line-number.folded,pre.editor-colors .gutter .line-number:after,pre.editor-colors .fold-marker:after { color: #abb2bf;}.syntax–comment { color: #5c6370; font-style: italic;}.syntax–comment .syntax–markup.syntax–link { color: #5c6370;}.syntax–entity.syntax–name.syntax–type { color: #e5c07b;}.syntax–entity.syntax–other.syntax–inherited-class { color: #98c379;}.syntax–keyword { color: #c678dd;}.syntax–keyword.syntax–control { color: #c678dd;}.syntax–keyword.syntax–operator { color: #abb2bf;}.syntax–keyword.syntax–other.syntax–special-method { color: #61afef;}.syntax–keyword.syntax–other.syntax–unit { color: #d19a66;}.syntax–storage { color: #c678dd;}.syntax–storage.syntax–type.syntax–annotation,.syntax–storage.syntax–type.syntax–primitive { color: #c678dd;}.syntax–storage.syntax–modifier.syntax–package,.syntax–storage.syntax–modifier.syntax–import { color: #abb2bf;}.syntax–constant { color: #d19a66;}.syntax–constant.syntax–variable { color: #d19a66;}.syntax–constant.syntax–character.syntax–escape { color: #56b6c2;}.syntax–constant.syntax–numeric { color: #d19a66;}.syntax–constant.syntax–other.syntax–color { color: #56b6c2;}.syntax–constant.syntax–other.syntax–symbol { color: #56b6c2;}.syntax–variable { color: #e06c75;}.syntax–variable.syntax–interpolation { color: #be5046;}.syntax–variable.syntax–parameter { color: #abb2bf;}.syntax–string { color: #98c379;}.syntax–string.syntax–regexp { color: #56b6c2;}.syntax–string.syntax–regexp .syntax–source.syntax–ruby.syntax–embedded { color: #e5c07b;}.syntax–string.syntax–other.syntax–link { color: #e06c75;}.syntax–punctuation.syntax–definition.syntax–comment { color: #5c6370;}.syntax–punctuation.syntax–definition.syntax–method-parameters,.syntax–punctuation.syntax–definition.syntax–function-parameters,.syntax–punctuation.syntax–definition.syntax–parameters,.syntax–punctuation.syntax–definition.syntax–separator,.syntax–punctuation.syntax–definition.syntax–seperator,.syntax–punctuation.syntax–definition.syntax–array { color: #abb2bf;}.syntax–punctuation.syntax–definition.syntax–heading,.syntax–punctuation.syntax–definition.syntax–identity { color: #61afef;}.syntax–punctuation.syntax–definition.syntax–bold { color: #e5c07b; font-weight: bold;}.syntax–punctuation.syntax–definition.syntax–italic { color: #c678dd; font-style: italic;}.syntax–punctuation.syntax–section.syntax–embedded { color: #be5046;}.syntax–punctuation.syntax–section.syntax–method,.syntax–punctuation.syntax–section.syntax–class,.syntax–punctuation.syntax–section.syntax–inner-class { color: #abb2bf;}.syntax–support.syntax–class { color: #e5c07b;}.syntax–support.syntax–type { color: #56b6c2;}.syntax–support.syntax–function { color: #56b6c2;}.syntax–support.syntax–function.syntax–any-method { color: #61afef;}.syntax–entity.syntax–name.syntax–function { color: #61afef;}.syntax–entity.syntax–name.syntax–class,.syntax–entity.syntax–name.syntax–type.syntax–class { color: #e5c07b;}.syntax–entity.syntax–name.syntax–section { color: #61afef;}.syntax–entity.syntax–name.syntax–tag { color: #e06c75;}.syntax–entity.syntax–other.syntax–attribute-name { color: #d19a66;}.syntax–entity.syntax–other.syntax–attribute-name.syntax–id { color: #61afef;}.syntax–meta.syntax–class { color: #e5c07b;}.syntax–meta.syntax–class.syntax–body { color: #abb2bf;}.syntax–meta.syntax–method-call,.syntax–meta.syntax–method { color: #abb2bf;}.syntax–meta.syntax–definition.syntax–variable { color: #e06c75;}.syntax–meta.syntax–link { color: #d19a66;}.syntax–meta.syntax–require { color: #61afef;}.syntax–meta.syntax–selector { color: #c678dd;}.syntax–meta.syntax–separator { background-color: #373b41; color: #abb2bf;}.syntax–meta.syntax–tag { color: #abb2bf;}.syntax–underline { text-decoration: underline;}.syntax–none { color: #abb2bf;}.syntax–invalid.syntax–deprecated { color: #523d14 !important; background-color: #e0c285 !important;}.syntax–invalid.syntax–illegal { color: white !important; background-color: #e05252 !important;}.syntax–markup.syntax–bold { color: #d19a66; font-weight: bold;}.syntax–markup.syntax–changed { color: #c678dd;}.syntax–markup.syntax–deleted { color: #e06c75;}.syntax–markup.syntax–italic { color: #c678dd; font-style: italic;}.syntax–markup.syntax–heading { color: #e06c75;}.syntax–markup.syntax–heading .syntax–punctuation.syntax–definition.syntax–heading { color: #61afef;}.syntax–markup.syntax–link { color: #56b6c2;}.syntax–markup.syntax–inserted { color: #98c379;}.syntax–markup.syntax–quote { color: #d19a66;}.syntax–markup.syntax–raw { color: #98c379;}.syntax–source.syntax–c .syntax–keyword.syntax–operator { color: #c678dd;}.syntax–source.syntax–cpp .syntax–keyword.syntax–operator { color: #c678dd;}.syntax–source.syntax–cs .syntax–keyword.syntax–operator { color: #c678dd;}.syntax–source.syntax–css .syntax–property-name,.syntax–source.syntax–css .syntax–property-value { color: #828997;}.syntax–source.syntax–css .syntax–property-name.syntax–support,.syntax–source.syntax–css .syntax–property-value.syntax–support { color: #abb2bf;}.syntax–source.syntax–elixir .syntax–source.syntax–embedded.syntax–source { color: #abb2bf;}.syntax–source.syntax–elixir .syntax–constant.syntax–language,.syntax–source.syntax–elixir .syntax–constant.syntax–numeric,.syntax–source.syntax–elixir .syntax–constant.syntax–definition { color: #61afef;}.syntax–source.syntax–elixir .syntax–variable.syntax–definition,.syntax–source.syntax–elixir .syntax–variable.syntax–anonymous { color: #c678dd;}.syntax–source.syntax–elixir .syntax–quoted { color: #98c379;}.syntax–source.syntax–elixir .syntax–keyword.syntax–special-method,.syntax–source.syntax–elixir .syntax–embedded.syntax–section,.syntax–source.syntax–elixir .syntax–embedded.syntax–source.syntax–empty { color: #e06c75;}.syntax–source.syntax–elixir .syntax–readwrite.syntax–module .syntax–punctuation { color: #e06c75;}.syntax–source.syntax–elixir .syntax–regexp.syntax–section,.syntax–source.syntax–elixir .syntax–regexp.syntax–string { color: #be5046;}.syntax–source.syntax–elixir .syntax–separator,.syntax–source.syntax–elixir .syntax–keyword.syntax–operator { color: #d19a66;}.syntax–source.syntax–elixir .syntax–variable.syntax–constant { color: #e5c07b;}.syntax–source.syntax–elixir .syntax–array,.syntax–source.syntax–elixir .syntax–scope,.syntax–source.syntax–elixir .syntax–section { color: #828997;}.syntax–source.syntax–gfm .syntax–markup { -webkit-font-smoothing: auto;}.syntax–source.syntax–gfm .syntax–link .syntax–entity { color: #61afef;}.syntax–source.syntax–go .syntax–storage.syntax–type.syntax–string { color: #c678dd;}.syntax–source.syntax–ini .syntax–keyword.syntax–other.syntax–definition.syntax–ini { color: #e06c75;}.syntax–source.syntax–java .syntax–storage.syntax–modifier.syntax–import { color: #e5c07b;}.syntax–source.syntax–java .syntax–storage.syntax–type { color: #e5c07b;}.syntax–source.syntax–java .syntax–keyword.syntax–operator.syntax–instanceof { color: #c678dd;}.syntax–source.syntax–java-properties .syntax–meta.syntax–key-pair { color: #e06c75;}.syntax–source.syntax–java-properties .syntax–meta.syntax–key-pair &gt; .syntax–punctuation { color: #abb2bf;}.syntax–source.syntax–js .syntax–keyword.syntax–operator { color: #56b6c2;}.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–delete,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–in,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–of,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–instanceof,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–new,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–typeof,.syntax–source.syntax–js .syntax–keyword.syntax–operator.syntax–void { color: #c678dd;}.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–dictionary.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json { color: #e06c75;}.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–dictionary.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json &gt; .syntax–punctuation.syntax–string { color: #e06c75;}.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–dictionary.syntax–json &gt; .syntax–value.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json,.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–array.syntax–json &gt; .syntax–value.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json,.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–dictionary.syntax–json &gt; .syntax–value.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json &gt; .syntax–punctuation,.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–array.syntax–json &gt; .syntax–value.syntax–json &gt; .syntax–string.syntax–quoted.syntax–json &gt; .syntax–punctuation { color: #98c379;}.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–dictionary.syntax–json &gt; .syntax–constant.syntax–language.syntax–json,.syntax–source.syntax–json .syntax–meta.syntax–structure.syntax–array.syntax–json &gt; .syntax–constant.syntax–language.syntax–json { color: #56b6c2;}.syntax–source.syntax–ruby .syntax–constant.syntax–other.syntax–symbol &gt; .syntax–punctuation { color: inherit;}.syntax–source.syntax–python .syntax–keyword.syntax–operator.syntax–logical.syntax–python { color: #c678dd;}.syntax–source.syntax–python .syntax–variable.syntax–parameter { color: #d19a66;} title date tags GCD详解 Tue Nov 21 2017 00:17:15 GMT+0800 (CST) GCD (Objective-C高级编程：iOS与OS X多线程和内存管理) GCD（Grand Central Dispatch） 详解GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址http://libdispatch.macosforge.org。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。GCD概要和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O）可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在这个并行队列在队列中被分配的那个线程执行。基本概念系统标准两个队列&nbsp;//全局队列，一个并行的队列dispatch_get_global_queue//主队列，主线程中的唯一队列，一个串行队列dispatch_get_main_queue自定义队列//串行队列dispatch_queue_create(“com.starming.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL)//并行队列dispatch_queue_create(“com.starming.concurrentqueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT)同步异步线程创建//同步线程dispatch_sync(…,&nbsp;^(block))//异步线程dispatch_async(…,&nbsp;^(block))队列（dispatch queue）Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。dipatch_queue_t&nbsp;queue;queue&nbsp;=&nbsp;dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。dispatch_queue_t&nbsp;queuequeue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT);自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级//dipatch_queue_attr_make_with_qos_classdispatch_queue_attr_t&nbsp;attr&nbsp;=&nbsp;dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL,&nbsp;QOS_CLASS_UTILITY,&nbsp;-1);dispatch_queue_t&nbsp;queue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.qosqueue”,&nbsp;attr);&nbsp;//dispatch_set_target_queuedispatch_queue_t&nbsp;queue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.settargetqueue”,NULL);&nbsp;//需要设置优先级的queuedispatch_queue_t&nbsp;referQueue&nbsp;=&nbsp;dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,&nbsp;0);&nbsp;//参考优先级dispatch_set_target_queue(queue,&nbsp;referQueue);&nbsp;//设置queue和referQueue的优先级一样dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下dispatch_queue_t&nbsp;serialQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);dispatch_queue_t&nbsp;firstQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.firstqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);dispatch_queue_t&nbsp;secondQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.secondqueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT);&nbsp;dispatch_set_target_queue(firstQueue,&nbsp;serialQueue);dispatch_set_target_queue(secondQueue,&nbsp;serialQueue);&nbsp;dispatch_async(firstQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:3.f];});dispatch_async(secondQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];});dispatch_async(secondQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:1.f];});队列类型队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block-&nbsp;(id)init;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self&nbsp;=&nbsp;[super&nbsp;init];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(self&nbsp;!=&nbsp;nil)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSString&nbsp;label&nbsp;=&nbsp;[NSString&nbsp;stringWithFormat:@”%@.isolation.%p”,&nbsp;[self&nbsp;class],&nbsp;self];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.isolationQueue&nbsp;=&nbsp;dispatch_queue_create([label&nbsp;UTF8String],&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label&nbsp;=&nbsp;[NSString&nbsp;stringWithFormat:@”%@.work.%p”,&nbsp;[self&nbsp;class],&nbsp;self];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.workQueue&nbsp;=&nbsp;dispatch_queue_create([label&nbsp;UTF8String],&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self;}5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。示例：后台加载显示图片override&nbsp;func&nbsp;viewDidLoad()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.viewDidLoad()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value),&nbsp;0))&nbsp;{&nbsp;//&nbsp;将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;overlayImage&nbsp;=&nbsp;self.faceOverlayImageFromImage(self.image)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_main_queue())&nbsp;{&nbsp;//&nbsp;新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.fadeInNewImage(overlayImage)&nbsp;//&nbsp;更新UI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}何时使用何种队列类型主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。可以使用下面的方法简化QoS等级参数的写法var&nbsp;GlobalMainQueue:&nbsp;dispatch_queue_t&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dispatch_get_main_queue()}var&nbsp;GlobalUserInteractiveQueue:&nbsp;dispatch_queue_t&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value),&nbsp;0)}var&nbsp;GlobalUserInitiatedQueue:&nbsp;dispatch_queue_t&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value),&nbsp;0)}var&nbsp;GlobalUtilityQueue:&nbsp;dispatch_queue_t&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value),&nbsp;0)}var&nbsp;GlobalBackgroundQueue:&nbsp;dispatch_queue_t&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value),&nbsp;0)}&nbsp;//使用起来就是这样，易读而且容易看出在使用哪个队列dispatch_async(GlobalUserInitiatedQueue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;overlayImage&nbsp;=&nbsp;self.faceOverlayImageFromImage(self.image)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(GlobalMainQueue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.fadeInNewImage(overlayImage)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}dispatch_once用法dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例+&nbsp;(UIColor&nbsp;)boringColor;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;UIColor&nbsp;color;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//只运行一次&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;dispatch_once_t&nbsp;onceToken;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_once(&amp;onceToken,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color&nbsp;=&nbsp;[UIColor&nbsp;colorWithRed:0.380f&nbsp;green:0.376f&nbsp;blue:0.376f&nbsp;alpha:1.000f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;color;}dispatch_async设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列-&nbsp;(void)processImage:(UIImage&nbsp;)image&nbsp;completionHandler:(void(^)(BOOL&nbsp;success))handler;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(self.isolationQueue,&nbsp;^(void){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;actual&nbsp;processing&nbsp;here&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(self.resultQueue,&nbsp;^(void){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler(YES);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});}可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。//代码框架dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;耗时的操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;更新界面&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});});&nbsp;//下载图片的示例dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSURL&nbsp;&nbsp;url&nbsp;=&nbsp;[NSURL&nbsp;URLWithString:@”http://avatar.csdn.net/2/C/D/1_totogo2010.jpg“];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSData&nbsp;&nbsp;data&nbsp;=&nbsp;[[NSData&nbsp;alloc]initWithContentsOfURL:url];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UIImage&nbsp;image&nbsp;=&nbsp;[[UIImage&nbsp;alloc]initWithData:data];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;!=&nbsp;nil)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.imageView.image&nbsp;=&nbsp;image;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}});dispatch_after延后执行dispatch_after只是延时提交block，不是延时立刻执行。-&nbsp;(void)foo{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;delayInSeconds&nbsp;=&nbsp;2.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_time_t&nbsp;popTime&nbsp;=&nbsp;dispatch_time(DISPATCH_TIME_NOW,&nbsp;(int64_t)&nbsp;(delayInSeconds&nbsp;&nbsp;NSEC_PER_SEC));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_after(popTime,&nbsp;dispatch_get_main_queue(),&nbsp;^(void){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;bar];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});}范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。func&nbsp;showOrHideNavPrompt()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;delayInSeconds&nbsp;=&nbsp;1.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;popTime&nbsp;=&nbsp;dispatch_time(DISPATCH_TIME_NOW,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int64(delayInSeconds&nbsp;&nbsp;Double(NSEC_PER_SEC)))&nbsp;//&nbsp;在这里声明推迟的时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_after(popTime,&nbsp;GlobalMainQueue)&nbsp;{&nbsp;//&nbsp;等待delayInSeconds将闭包异步到主队列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;count&nbsp;=&nbsp;PhotoManager.sharedManager.photos.count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;count&nbsp;&gt;&nbsp;0&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.navigationItem.prompt&nbsp;=&nbsp;nil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.navigationItem.prompt&nbsp;=&nbsp;”Add&nbsp;photos&nbsp;with&nbsp;faces&nbsp;to&nbsp;Googlyify&nbsp;them!”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}例子中的dispatch time的参数，可以先看看函数原型dispatch_time_t&nbsp;dispatch_time&nbsp;(&nbsp;dispatch_time_t&nbsp;when,&nbsp;int64_t&nbsp;delta&nbsp;);第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化&nbsp;#define&nbsp;NSEC_PER_SEC&nbsp;1000000000ull&nbsp;//每秒有多少纳秒&nbsp;#define&nbsp;USEC_PER_SEC&nbsp;1000000ull&nbsp;&nbsp;&nbsp;&nbsp;//每秒有多少毫秒&nbsp;#define&nbsp;NSEC_PER_USEC&nbsp;1000ull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//每毫秒有多少纳秒这样如果要表示一秒就可以这样写dispatch_time(DISPATCH_TIME_NOW,&nbsp;1&nbsp;&nbsp;NSEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW,&nbsp;1000&nbsp;&nbsp;USEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW,&nbsp;USEC_PER_SEC&nbsp;&nbsp;NSEC_PER_USEC);dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样//创建队列self.isolationQueue&nbsp;=&nbsp;dispatch_queue_create([label&nbsp;UTF8String],&nbsp;DISPATCH_QUEUE_CONCURRENT);//改变setter-&nbsp;(void)setCount:(NSUInteger)count&nbsp;forKey:(NSString&nbsp;)key{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;[key&nbsp;copy];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//确保所有barrier都是async异步的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_barrier_async(self.isolationQueue,&nbsp;^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;==&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self.counts&nbsp;removeObjectForKey:key];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.counts[key]&nbsp;=&nbsp;@(count);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});}-&nbsp;(void)dispatchBarrierAsyncDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;dataQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.dataqueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dataQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”read&nbsp;data&nbsp;1”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dataQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”read&nbsp;data&nbsp;2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;//等待前面的都完成，在执行barrier后面的&nbsp;&nbsp;&nbsp;&nbsp;dispatch_barrier_async(dataQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”write&nbsp;data&nbsp;1”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:1];&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dataQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:1.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”read&nbsp;data&nbsp;3”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dataQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”read&nbsp;data&nbsp;4”);&nbsp;&nbsp;&nbsp;&nbsp;});}swift示例//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。private&nbsp;let&nbsp;concurrentPhotoQueue&nbsp;=&nbsp;dispatch_queue_create(“com.raywenderlich.GooglyPuff.photoQueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT)&nbsp;func&nbsp;addPhoto(photo:&nbsp;Photo)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_barrier_async(concurrentPhotoQueue)&nbsp;{&nbsp;//&nbsp;将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._photos.append(photo)&nbsp;//&nbsp;barrier能够保障不会和其他任务同时进行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(GlobalMainQueue)&nbsp;{&nbsp;//&nbsp;涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.postContentAddedNotification()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。var&nbsp;photos:&nbsp;[Photo]&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;photosCopy:&nbsp;[Photo]!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(concurrentPhotoQueue)&nbsp;{&nbsp;//&nbsp;同步调度到concurrentPhotoQueue队列执行读操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;photosCopy&nbsp;=&nbsp;self._photos&nbsp;//&nbsp;保存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;photosCopy}//这样读写问题都解决了。都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。dispatch_apply进行快速迭代类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。for&nbsp;(size_t&nbsp;y&nbsp;=&nbsp;0;&nbsp;y&nbsp;&lt;&nbsp;height;&nbsp;++y)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(size_t&nbsp;x&nbsp;=&nbsp;0;&nbsp;x&nbsp;&lt;&nbsp;width;&nbsp;++x)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Do&nbsp;something&nbsp;with&nbsp;x&nbsp;and&nbsp;y&nbsp;here&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}//因为可以并行执行，所以使用dispatch_apply可以运行的更快-&nbsp;(void)dispatchApplyDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;concurrentQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,&nbsp;DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_apply(10,&nbsp;concurrentQueue,&nbsp;^(size_t&nbsp;i)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”%zu”,i);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”The&nbsp;end”);&nbsp;//这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行}dispatch_apply能避免线程爆炸，因为GCD会管理并发-&nbsp;(void)dealWiththreadWithMaybeExplode:(BOOL)explode&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;concurrentQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(explode)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//有问题的情况，可能会死锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;999&nbsp;;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”wrong&nbsp;%d”,i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;something&nbsp;hard&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//会优化很多，能够利用GCD管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_apply(999,&nbsp;concurrentQueue,&nbsp;^(size_t&nbsp;i){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”correct&nbsp;%zu”,i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;something&nbsp;hard&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;}}示例：func&nbsp;downloadPhotosWithCompletion(completion:&nbsp;BatchPhotoDownloadingCompletionClosure?)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;storedError:&nbsp;NSError!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;downloadGroup&nbsp;=&nbsp;dispatch_group_create()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;addresses&nbsp;=&nbsp;[OverlyAttachedGirlfriendURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuccessKidURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LotsOfFacesURLString]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_apply(UInt(addresses.count),&nbsp;GlobalUserInitiatedQueue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;index&nbsp;=&nbsp;Int(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;address&nbsp;=&nbsp;addresses[index]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;url&nbsp;=&nbsp;NSURL(string:&nbsp;address)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;photo&nbsp;=&nbsp;DownloadPhoto(url:&nbsp;url!)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image,&nbsp;error&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;error&nbsp;=&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedError&nbsp;=&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhotoManager.sharedManager.addPhoto(photo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_notify(downloadGroup,&nbsp;GlobalMainQueue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;completion&nbsp;=&nbsp;completion&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completion(error:&nbsp;storedError)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}Block组合Dispatch_groupsdispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。第一种使用dispatch_group_wait的swift的例子：func&nbsp;downloadPhotosWithCompletion(completion:&nbsp;BatchPhotoDownloadingCompletionClosure?)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(GlobalUserInitiatedQueue)&nbsp;{&nbsp;//&nbsp;因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;storedError:&nbsp;NSError!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;downloadGroup&nbsp;=&nbsp;dispatch_group_create()&nbsp;//&nbsp;创建一个dispatch&nbsp;group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;address&nbsp;in&nbsp;[OverlyAttachedGirlfriendURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuccessKidURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LotsOfFacesURLString]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;url&nbsp;=&nbsp;NSURL(string:&nbsp;address)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(downloadGroup)&nbsp;//&nbsp;dispatch_group_enter是通知dispatch&nbsp;group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;photo&nbsp;=&nbsp;DownloadPhoto(url:&nbsp;url!)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image,&nbsp;error&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;error&nbsp;=&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedError&nbsp;=&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(downloadGroup)&nbsp;//&nbsp;保持和dispatch_group_enter配对。通知任务已经完成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhotoManager.sharedManager.addPhoto(photo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_wait(downloadGroup,&nbsp;DISPATCH_TIME_FOREVER)&nbsp;//&nbsp;dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(GlobalMainQueue)&nbsp;{&nbsp;//&nbsp;这里可以保证所有图片任务都完成，然后在main&nbsp;queue里加入完成后要处理的闭包，会在main&nbsp;queue里执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;completion&nbsp;=&nbsp;completion&nbsp;{&nbsp;//&nbsp;执行闭包内容&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completion(error:&nbsp;storedError)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}oc例子-&nbsp;(void)dispatchGroupWaitDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;concurrentQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_t&nbsp;group&nbsp;=&nbsp;dispatch_group_create();&nbsp;&nbsp;&nbsp;&nbsp;//在group中添加队列的block&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_wait(group,&nbsp;DISPATCH_TIME_FOREVER);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”go&nbsp;on”);}第二种使用dispatch_group_notify的swift的例子：func&nbsp;downloadPhotosWithCompletion(completion:&nbsp;BatchPhotoDownloadingCompletionClosure?)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;不用加dispatch_async，因为没有阻塞主进程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;storedError:&nbsp;NSError!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;downloadGroup&nbsp;=&nbsp;dispatch_group_create()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;address&nbsp;in&nbsp;[OverlyAttachedGirlfriendURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuccessKidURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LotsOfFacesURLString]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;url&nbsp;=&nbsp;NSURL(string:&nbsp;address)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;photo&nbsp;=&nbsp;DownloadPhoto(url:&nbsp;url!)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image,&nbsp;error&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;error&nbsp;=&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedError&nbsp;=&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhotoManager.sharedManager.addPhoto(photo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_notify(downloadGroup,&nbsp;GlobalMainQueue)&nbsp;{&nbsp;//&nbsp;dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch&nbsp;groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;completion&nbsp;=&nbsp;completion&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completion(error:&nbsp;storedError)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}oc例子//dispatch_group_notify-&nbsp;(void)dispatchGroupNotifyDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;concurrentQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_t&nbsp;group&nbsp;=&nbsp;dispatch_group_create();&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_notify(group,&nbsp;dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”end”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”can&nbsp;continue”);&nbsp;}//dispatch_group_wait-&nbsp;(void)dispatchGroupWaitDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;concurrentQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.concurrentqueue”,DISPATCH_QUEUE_CONCURRENT);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_t&nbsp;group&nbsp;=&nbsp;dispatch_group_create();&nbsp;&nbsp;&nbsp;&nbsp;//在group中添加队列的block&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_async(group,&nbsp;concurrentQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_wait(group,&nbsp;DISPATCH_TIME_FOREVER);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”can&nbsp;continue”);}如何对现有API使用dispatch_group_t&nbsp;//给Core&nbsp;Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。-&nbsp;(void)withGroup:(dispatch_group_t)group&nbsp;performBlock:(dispatch_block_t)block{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(group&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;performBlock:block];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(group);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;performBlock:^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(group);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}&nbsp;//NSURLConnection也可以这样做+&nbsp;(void)withGroup:(dispatch_group_t)group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendAsynchronousRequest:(NSURLRequest&nbsp;)request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue:(NSOperationQueue&nbsp;)queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionHandler:(void&nbsp;(^)(NSURLResponse,&nbsp;NSData,&nbsp;NSError))handler{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(group&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;sendAsynchronousRequest:request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue:queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionHandler:handler];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(group);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;sendAsynchronousRequest:request&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue:queue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionHandler:^(NSURLResponse&nbsp;response,&nbsp;NSData&nbsp;data,&nbsp;NSError&nbsp;error){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler(response,&nbsp;data,&nbsp;error);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(group);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}注意事项dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的Dispatch Block队列执行任务都是block的方式，创建block&lt;/li&gt; &lt;li&gt;&lt;p&gt;(void)createDispatchBlock { //normal way dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block = dispatch_block_create(0, ^{&lt;/p&gt; &lt;pre class=&quot;editor-colors lang-&quot;&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;syntax--text syntax--plain syntax--null-grammar&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;NSLog(@&quot;run&amp;nbsp;block&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;p&gt; }); dispatch_async(concurrentQueue, block);&lt;/p&gt; &lt;p&gt; //QOS way dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{&lt;/p&gt; &lt;pre class=&quot;editor-colors lang-&quot;&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;syntax--text syntax--plain syntax--null-grammar&quot;&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;NSLog(@&quot;run&amp;nbsp;qos&amp;nbsp;block&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;p&gt; }); dispatch_async(concurrentQueue, qosBlock); }dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束-&nbsp;(void)dispatchBlockWaitDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;serialQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_t&nbsp;block&nbsp;=&nbsp;dispatch_block_create(0,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”star”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:5.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”end”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(serialQueue,&nbsp;block);&nbsp;&nbsp;&nbsp;&nbsp;//设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_wait(block,&nbsp;DISPATCH_TIME_FOREVER);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”ok,&nbsp;now&nbsp;can&nbsp;go&nbsp;on”);}dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block-&nbsp;(void)dispatchBlockNotifyDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;serialQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_t&nbsp;firstBlock&nbsp;=&nbsp;dispatch_block_create(0,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”first&nbsp;block&nbsp;start”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”first&nbsp;block&nbsp;end”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(serialQueue,&nbsp;firstBlock);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_t&nbsp;secondBlock&nbsp;=&nbsp;dispatch_block_create(0,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”second&nbsp;block&nbsp;run”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;//first&nbsp;block执行完才在serial&nbsp;queue中执行second&nbsp;block&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_notify(firstBlock,&nbsp;serialQueue,&nbsp;secondBlock);}dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消-&nbsp;(void)dispatchBlockCancelDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;serialQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_t&nbsp;firstBlock&nbsp;=&nbsp;dispatch_block_create(0,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”first&nbsp;block&nbsp;start”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:2.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”first&nbsp;block&nbsp;end”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_t&nbsp;secondBlock&nbsp;=&nbsp;dispatch_block_create(0,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”second&nbsp;block&nbsp;run”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(serialQueue,&nbsp;firstBlock);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(serialQueue,&nbsp;secondBlock);&nbsp;&nbsp;&nbsp;&nbsp;//取消secondBlock&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_cancel(secondBlock);}使用dispatch block object（调度块）在任务执行前进行取消dispatch block object可以为队列中的对象设置 示例，下载图片中途进行取消func&nbsp;downloadPhotosWithCompletion(completion:&nbsp;BatchPhotoDownloadingCompletionClosure?)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;storedError:&nbsp;NSError!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;downloadGroup&nbsp;=&nbsp;dispatch_group_create()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;addresses&nbsp;=&nbsp;[OverlyAttachedGirlfriendURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuccessKidURLString,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LotsOfFacesURLString]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addresses&nbsp;+=&nbsp;addresses&nbsp;+&nbsp;addresses&nbsp;//&nbsp;扩展address数组，复制3份&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;blocks:&nbsp;[dispatch_block_t]&nbsp;=&nbsp;[]&nbsp;//&nbsp;一个保存block的数组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;0&nbsp;..&lt;&nbsp;addresses.count&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_enter(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;block&nbsp;=&nbsp;dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS)&nbsp;{&nbsp;//&nbsp;创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;index&nbsp;=&nbsp;Int(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;address&nbsp;=&nbsp;addresses[index]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;url&nbsp;=&nbsp;NSURL(string:&nbsp;address)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;photo&nbsp;=&nbsp;DownloadPhoto(url:&nbsp;url!)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image,&nbsp;error&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;error&nbsp;=&nbsp;error&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;storedError&nbsp;=&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(downloadGroup)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhotoManager.sharedManager.addPhoto(photo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocks.append(block)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(GlobalMainQueue,&nbsp;block)&nbsp;//&nbsp;把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;block&nbsp;in&nbsp;blocks[3&nbsp;..&lt;&nbsp;blocks.count]&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;cancel&nbsp;=&nbsp;arc4random_uniform(2)&nbsp;//&nbsp;随机返回一个整数，会返回0或1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;cancel&nbsp;==&nbsp;1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_block_cancel(block)&nbsp;//&nbsp;如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_leave(downloadGroup)&nbsp;//&nbsp;因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_group_notify(downloadGroup,&nbsp;GlobalMainQueue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;let&nbsp;completion&nbsp;=&nbsp;completion&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completion(error:&nbsp;storedError)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}Dispatch IO 文件操作dispatch&nbsp;io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。&nbsp;dispatch_async(queue,^{/read&nbsp;0-99&nbsp;bytes/});dispatch_async(queue,^{/read&nbsp;100-199&nbsp;bytes/});dispatch_async(queue,^{/read&nbsp;200-299&nbsp;bytes/});dispatch_io_create：创建dispatch iodispatch_io_set_low_water：指定切割文件大小dispatch_io_read：读取切割的文件然后合并。苹果系统日志API里用到了这个技术，可以在这里查看：https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.cpipe_q&nbsp;=&nbsp;dispatch_queue_create(“PipeQ”,&nbsp;NULL);//创建pipe_channel&nbsp;=&nbsp;dispatch_io_create(DISPATCH_IO_STREAM,&nbsp;fd,&nbsp;pipe_q,&nbsp;^(int&nbsp;err){&nbsp;&nbsp;&nbsp;&nbsp;close(fd);});&nbsp;out_fd&nbsp;=&nbsp;fdpair[1];//设置切割大小dispatch_io_set_low_water(pipe_channel,&nbsp;SIZE_MAX);&nbsp;dispatch_io_read(pipe_channel,&nbsp;0,&nbsp;SIZE_MAX,&nbsp;pipe_q,&nbsp;^(bool&nbsp;done,&nbsp;dispatch_data_t&nbsp;pipedata,&nbsp;int&nbsp;err){&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err&nbsp;==&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;dispatch_data_get_size(pipedata);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//对每次切块数据的处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;bytes&nbsp;=&nbsp;NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;encoded;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_t&nbsp;eval;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_data_t&nbsp;md&nbsp;=&nbsp;dispatch_data_create_map(pipedata,&nbsp;(const&nbsp;void&nbsp;*)&amp;bytes,&nbsp;&amp;len);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encoded&nbsp;=&nbsp;asl_core_encode_buffer(bytes,&nbsp;len);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asl_msg_set_key_val(aux,&nbsp;ASL_KEY_AUX_DATA,&nbsp;encoded);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(encoded);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eval&nbsp;=&nbsp;_asl_evaluate_send(NULL,&nbsp;(aslmsg)aux,&nbsp;-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_asl_send_message(NULL,&nbsp;eval,&nbsp;aux,&nbsp;NULL);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asl_msg_release(aux);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_release(md);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(done)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//semaphore&nbsp;+1使得不需要再等待继续执行下去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(sem);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_release(pipe_channel);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_release(pipe_q);&nbsp;&nbsp;&nbsp;&nbsp;}});Dispatch Source 用GCD监视进程Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表方法说明DISPATCH_SOURCE_TYPE_DATA_ADD数据增加DISPATCH_SOURCE_TYPE_DATA_OR数据ORDISPATCH_SOURCE_TYPE_MACH_SENDMach端口发送DISPATCH_SOURCE_TYPE_MACH_RECVMach端口接收DISPATCH_SOURCE_TYPE_MEMORYPRESSURE内存情况DISPATCH_SOURCE_TYPE_PROC进程事件DISPATCH_SOURCE_TYPE_READ读数据DISPATCH_SOURCE_TYPE_SIGNAL信号DISPATCH_SOURCE_TYPE_TIMER定时器DISPATCH_SOURCE_TYPE_VNODE文件系统变化DISPATCH_SOURCE_TYPE_WRITE文件写入方法dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。dispatch_source_set_event_handler：设置事件处理handlerdispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。NSRunningApplication&nbsp;mail&nbsp;=&nbsp;[NSRunningApplication&nbsp;runningApplicationsWithBundleIdentifier:@”com.apple.mail”];if&nbsp;(mail&nbsp;==&nbsp;nil)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;}pid_t&nbsp;const&nbsp;pid&nbsp;=&nbsp;mail.processIdentifier;self.source&nbsp;=&nbsp;dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,&nbsp;pid,&nbsp;DISPATCH_PROC_EXIT,&nbsp;DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(self.source,&nbsp;^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”Mail&nbsp;quit.”);});//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法dispatch_resume(self.source);监视文件夹内文件变化NSURL&nbsp;directoryURL;&nbsp;//&nbsp;assume&nbsp;this&nbsp;is&nbsp;set&nbsp;to&nbsp;a&nbsp;directoryint&nbsp;const&nbsp;fd&nbsp;=&nbsp;open([[directoryURL&nbsp;path]&nbsp;fileSystemRepresentation],&nbsp;O_EVTONLY);if&nbsp;(fd&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buffer[80];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strerror_r(errno,&nbsp;buffer,&nbsp;sizeof(buffer));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”Unable&nbsp;to&nbsp;open&nbsp;\\”%@\\”:&nbsp;%s&nbsp;(%d)”,&nbsp;[directoryURL&nbsp;path],&nbsp;buffer,&nbsp;errno);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;}dispatch_source_t&nbsp;source&nbsp;=&nbsp;dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,&nbsp;fd,DISPATCH_VNODE_WRITE&nbsp;|&nbsp;DISPATCH_VNODE_DELETE,&nbsp;DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source,&nbsp;^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;const&nbsp;data&nbsp;=&nbsp;dispatch_source_get_data(source);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;&amp;&nbsp;DISPATCH_VNODE_WRITE)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”The&nbsp;directory&nbsp;changed.”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;&amp;&nbsp;DISPATCH_VNODE_DELETE)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”The&nbsp;directory&nbsp;has&nbsp;been&nbsp;deleted.”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}});dispatch_source_set_cancel_handler(source,&nbsp;^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd);});self.source&nbsp;=&nbsp;source;dispatch_resume(self.source);//还要注意需要用DISPATCH_VNODE_DELETE&nbsp;去检查监视的文件或文件夹是否被删除，如果删除了就停止监听NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。dispatch_source_t&nbsp;source&nbsp;=&nbsp;dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0,&nbsp;0,&nbsp;DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source,&nbsp;^(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”Time&nbsp;flies.”);});dispatch_time_t&nbsp;startdispatch_source_set_timer(source,&nbsp;DISPATCH_TIME_NOW,&nbsp;5ull&nbsp;&nbsp;NSEC_PER_SEC,100ull&nbsp;&nbsp;NSEC_PER_MSEC);self.source&nbsp;=&nbsp;source;dispatch_resume(self.source);Dispatch Semaphore和的介绍另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。//dispatch&nbsp;semaphore-&nbsp;(void)dispatchSemaphoreDemo&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//创建semaphore&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_t&nbsp;semaphore&nbsp;=&nbsp;dispatch_semaphore_create(0);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”start”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[NSThread&nbsp;sleepForTimeInterval:1.f];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”semaphore&nbsp;+1”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(semaphore);&nbsp;//+1&nbsp;semaphore&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_wait(semaphore,&nbsp;DISPATCH_TIME_FOREVER);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”continue”);}锁这里简单介绍下iOS中常用的各种锁和他们的性能。NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。@synchronized：更加简单。dispatch_suspend和dispatch_resume挂起和恢复队列dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。dispatch_set_context和dispatch_get_contextGCD深入操作缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close测试：使用dispatch_benchmark小工具原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。GCD死锁当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。-&nbsp;(void)deadLockCase1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;//主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);}-&nbsp;(void)deadLockCase2&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);}-&nbsp;(void)deadLockCase3&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_queue_t&nbsp;serialQueue&nbsp;=&nbsp;dispatch_queue_create(“com.starming.gcddemo.serialqueue”,&nbsp;DISPATCH_QUEUE_SERIAL);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(serialQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//串行队列里面同步一个串行队列就会死锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(serialQueue,&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”4”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”5”);}-&nbsp;(void)deadLockCase4&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_global_queue(0,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将同步的串行队列放到另外一个线程就能够解决&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”4”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”5”);}-&nbsp;(void)deadLockCase5&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_async(dispatch_get_global_queue(0,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”1”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//回到主线程发现死循环后面就没法执行了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_sync(dispatch_get_main_queue(),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”2”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”3”);&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”4”);&nbsp;&nbsp;&nbsp;&nbsp;//死循环&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(1)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;}}GCD实际使用FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁作用类似objc_setAssociatedObject跟objc_getAssociatedObjectstatic const void const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;//创建串行队列，所有数据库的操作都在这个队列里_queue&nbsp;=&nbsp;dispatch_queue_create([[NSString&nbsp;stringWithFormat:@”fmdb.%@”,&nbsp;self]&nbsp;UTF8String],&nbsp;NULL);//标记队列dispatch_queue_set_specific(_queue,&nbsp;kDispatchQueueSpecificKey,&nbsp;(bridge&nbsp;void&nbsp;)self,&nbsp;NULL);&nbsp;//检查是否是同一个队列来避免死锁的方法-&nbsp;(void)inDatabase:(void&nbsp;(^)(FMDatabase&nbsp;db))block&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;FMDatabaseQueue&nbsp;*currentSyncQueue&nbsp;=&nbsp;(bridge&nbsp;id)dispatch_get_specific(kDispatchQueueSpecificKey);&nbsp;&nbsp;&nbsp;&nbsp;assert(currentSyncQueue&nbsp;!=&nbsp;self&nbsp;&amp;&amp;&nbsp;”inDatabase:&nbsp;was&nbsp;called&nbsp;reentrantly&nbsp;on&nbsp;the&nbsp;same&nbsp;queue,&nbsp;which&nbsp;would&nbsp;lead&nbsp;to&nbsp;a&nbsp;deadlock”);}DTCoreText使用GCD加快解析速度DTCoreText采用的是SAX解析，iOS自带了XML/HTML的解析引擎libxml，提供了两个解析接口，DOM解析和SAX解析，前者使用简单但是占用内存多，SAX解析由于不会返回一个dom树，采用的是查到一个标签比如回调startElement方法碰到内容就回调_characters碰到类似就回调endElement这样的方式。根据这种解析方式DTCoreText使用多线程解析能够更快的解析，DTHTMLAttributedStringBuilder使用三个dispatch_queue_dataParsingQueue：解析html的_treeBuildingQueue：生成dom树的_stringAssemblyQueue：组装NSAttributeString的 获取三个队列全部完成采用了dispatch_group的dispatch_group_wait这种阻塞同步方式来返回结果。iOS系统版本新特性iOS8iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比Global queueCorresponding QoS class说明Main threadNSQualityOfServiceUserInteractiveUI相关，交互等DISPATCH_QUEUE_PRIORITY_HIGHNSQualityOfServiceUserInitiated用户发起需要马上得到结果进行后续任务DISPATCH_QUEUE_PRIORITY_DEFAULTNSQualityOfServiceDefault默认的不应该使用这个设置任务DISPATCH_QUEUE_PRIORITY_LOWNSQualityOfServiceUtility花费时间稍多比如下载，需要几秒或几分钟的DISPATCH_QUEUE_PRIORITY_BACKGROUNDNSQualityOfServiceBackground不可见在后台的操作可能需要好几分钟甚至几小时的","categories":[],"tags":[]},{"title":"CocoaPods利用sourectree发布自己的私有库","slug":"CocoaPods利用sourectree发布自己的私有库","date":"2017-10-21T14:55:10.000Z","updated":"2017-11-05T07:29:35.000Z","comments":true,"path":"2017/10/21/CocoaPods利用sourectree发布自己的私有库/","link":"","permalink":"http://taodongbo.cn/2017/10/21/CocoaPods利用sourectree发布自己的私有库/","excerpt":"","text":"1.创建Pod项目工程最近被公司项目忙的喘不过起来，有好几天没更新博客了，但心里一直惦记着这事，回来的时候太累了，吃完饭就睡了，只能周末来更新了。。。 1.cd进入要创建项目的目录然后 执行以下命令 1234#pod lib create [项目名]$pod lib create TBFontAdjust 接着在Terminal控制台会输出5个问题： 1.What language do you want to use?? [ Swift / ObjC ] ObjC 第一个问题是问你选择Swift还是Objc构建项目。此教程 选的是ObjC 2.Would you like to include a demo application with your library? [ Yes / No ] Yes 第二个问题问你是否需要创建一个Demo项目，此教程选的是Yes 3.Which testing frameworks will you use? [ Specta / Kiwi / None ] None 第三个问题让你是否选择一个测试框架，此教程选 None 4.Would you like to do view based testing? [ Yes / No ] Yes 5.What is your class prefix? tdb 填写完成后，会自动打开工程。 2.配置pod工程1.首先得pod 工程push到远程仓库，我选用sourectree比较直观 本地-&gt;+新仓库-&gt;添加已经存在的仓库 导入后，点击右键发布到远程 根据需求选择私有（github要收费）还是公有 发布后，点击进项目，给项目加一个标签 0.1.0（这个要与podspec一致）标签推送到远程 然后，登录github将下载地址copy出来，用来填写配置信息。 2.配置123456789101112131415161718192021222324252627282930313233343536373839404142Pod::Spec.new do |s| s.name = &apos;TBFontAdjust&apos;//项目名 s.version = &apos;0.1.0&apos;//版本 s.summary = &apos;iOS adjust test&apos;//简介# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don&apos;t worry about the indent, CocoaPods strips it!//描述 s.description = &lt;&lt;-DESC测试 DESC s.homepage = &apos;https://github.com/bobtaocool/TBFontAdjust&apos; # s.screenshots = &apos;www.example.com/screenshots_1&apos;, &apos;www.example.com/screenshots_2&apos; #开源协议 s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; #作者 s.author = &#123; &apos;TDB&apos; =&gt; &apos;1639008265@qq.com&apos; &#125; #源代码的链接地址 s.source = &#123; :git =&gt; &apos;https://github.com/bobtaocool/TBFontAdjust.git&apos;, :tag =&gt; s.version.to_s &#125; # s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos; #支持的平台及版本 s.ios.deployment_target = &apos;8.0&apos; #资源文件地址（把你的库代码放在这个Classes） s.source_files = &apos;TBFontAdjust/Classes/**/*&apos; # s.resource_bundles = &#123; # &apos;TBFontAdjust&apos; =&gt; [&apos;TBFontAdjust/Assets/*.png&apos;] # &#125;#公开头文件地址 # s.public_header_files = &apos;Pod/Classes/**/*.h&apos;#所需的framework，多个用逗号隔开 # s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;end 配置完成可以进行验证 pod lib lint 如出现警告：可以 podspec –use-libraries –allow-warnings 如果出现passed validation说明配置没问题 配置好后，sourectree 提交,推送到远程。 3.本地测试打开Example工程目录Podfile文件修改下pod 的引用 12#pod &apos;MyLib&apos;, :path =&gt; &apos;../&apos; # 指定路径pod &apos;TBFontAdjust&apos;, :podspec =&gt; &apos;../TBFontAdjust.podspec&apos; 然后在Example工程目录下执行pod update命令 打开项目工程，现在可以看到库文件都被加载到Pods子项目中了. 2.创建私有的仓库(Spec Repo)执行以下命令:(库名，地址需和配置文件填写一样) pod repo add 库名 地址 TBFontAdjust.podspec提交到远程Spec Repo仓库中cd进入TBFontAdjust项目根目录 12# pod repo push [Repo名] [podspec 文件名字]$ pod repo push TBFontAdjust TBFontAdjust.podspec 如果提交成功可以在~/.cocoapods/repos/MySpecs目录下查看 上传项目到Cocoapods官方的仓库里去1pod trunk push TBFontAdjust.podspec 如果出现[!] You need to register a session first 执行命令注册: pod trunk register xxxx@qq.com tdb 再次执行:pod trunk push TBFontAdjust.podspec 123456789101112131415Updating spec repo `master`Validating podspec -&gt; TBFontAdjust (0.1.0)Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 TBFontAdjust (0.1.0) successfully published 📅 October 21st, 08:47 🌎 https://cocoapods.org/pods/TBFontAdjust 👍 Tell your friends!--------------------------------------------------------------------------------bogon:TBFontAdjust bob$ 说明提交成功了. 3.查看操作是否成功pod search TBFontAdjust 有时候会遇到搜索不到的情况: [!] Unable to find a pod with name, author, summary, or description matching TBFontAdjust 当遇到上面这种情况的时候，按如下步骤进行操作：执行pod setup。执行该指令之后，我们再试试“pod search GofWebImage”，如果能够成功搜索出结果，那么不需要做下面步骤的操作；如果还是搜索不到，那么继续后续步骤；删除~/Library/Caches/CocoaPods目录下的s 如果出现这个 [!] An unexpected version directory Assets was encountered for the 解决方法:进入指定文件夹repos把TBFontAdjust删除即可。 参考链接:CocoaPods应用篇之搭建并发布自己的私有库 利用CocoaPods创建私有库","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://taodongbo.cn/tags/工具/"}]},{"title":"CocoaPods安装及出现的问题总结","slug":"CocoaPods安装及出现的问题总结","date":"2017-10-16T08:28:34.000Z","updated":"2017-10-16T14:20:53.000Z","comments":true,"path":"2017/10/16/CocoaPods安装及出现的问题总结/","link":"","permalink":"http://taodongbo.cn/2017/10/16/CocoaPods安装及出现的问题总结/","excerpt":"","text":"Cocopod 是iOS开发中常用的第三方管理工具，通过CocoaPods，我们可以将第三方的依赖库统一管理起来，配置和更新只需要通过简单的几行命令即可完成，大大的提高了实际开发中的工作效率，掌握CocoaPods的使用是必不可少的基本技能了。 安装CocoaPods1.安装前先升级Ruby环境12$sudo gem update —system 由于墙的原因会导致这一步非常缓慢,可以用淘宝的Ruby镜像来访问该网站 12$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 查看是否更换成功: 12gem sources -l 安装Cocoapods1sudo gem install cocoapods 这个时候会提示你输入密码 输入后开始安装… 安装成功后 查看版本 1$ pod --version 使用CocoaPods搜索目标库12$ pod search 库名 创建Podfile1234$ cd /项目文件touch Podfile //创建Podfile 创建成功后会在目录文件夹看到 编辑Podfile12$ vim Podfile 将搜索出来的库，拷贝进去配置如下图: 具体参考:cocoapods 123platform :ios, ‘7.0’ ／／支持的最低版本inhibit_all_warnings! //去除第三方的警告use_frameworks! //修改引入方式，加了这句引入使用#import ” ” ; 未加使用#import &lt; &gt; 执行安装／更新123pod installpod update CocoaPods 实现快速更新不检查CocoaPods specs更新 12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 升级CocoaPods12345671.添加镜像$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -l2.升级 gem查看gem gem --versionsudo gem update --system 1-2这个和安装流程差不多，不再重复 123.升级cocopodsudo gem install -n /usr/local/bin cocoapods --pre 1234.设置pod 仓库pod setup 125.查看版本pod --version CocoaPods 使用中的一些问题CocoaPods 搜索不到最新的版本库1231.cocoapods的版本过低2.还没有更新本地仓库 按照上述更新cocoapods即可! github上项目下载打开出错123diff: /../Podfile.lock: No such file or directory diff: Manifest.lock: No such file or directory error: The sandbox is not in sync with the Podfile.lock. Run &apos;pod install&apos; or update your CocoaPods installation.` 1.关闭当前的工作空间，删除掉文件夹中的workspace2.然后重新pod install。3.install完成之后，通过workspace打开工作空间，clean+build即可： 12rm -rf MyProject.xcworkspace pod install 多个xcode出现问题1sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 那么你的命令行就要修改一下： 1sudo xcode-select -switch /Applications/Xcode 7.3.1.app/Contents/Developer 根据你默认的xcode来修改在/Applications/和/Contents/Developer中间的app的名字，如果你默认的是Xcode x.x.x.app，中间就要替换掉哟！","categories":[],"tags":[{"name":"工具推荐","slug":"工具推荐","permalink":"http://taodongbo.cn/tags/工具推荐/"}]},{"title":"MarkDown的基本使用","slug":"MarkDown的基本使用","date":"2017-10-12T01:49:44.000Z","updated":"2017-10-16T01:55:38.000Z","comments":true,"path":"2017/10/12/MarkDown的基本使用/","link":"","permalink":"http://taodongbo.cn/2017/10/12/MarkDown的基本使用/","excerpt":"","text":"前几天搭建好了个人网站，买了域名，折腾了好几个晚上，终于往事俱备，只欠东风了。估摸着第一篇写些啥，既然需要Markdown来编写，那就从markdown开刀吧! 写博客必须要有一定的自制力，才能坚持下去，上班没法写，只能下班抽点时间出来总结一下，篇幅，数量不定，经过岁月沉淀的出来的才是好博客。 工欲善其事，必先利其器！ 我使用的工具是:Atom 下面进入正题： 标题123456#一级标题##二级标题###三级标题####四级标题#####五及标题 展示效果如下图所示： 字体123456**粗体***斜体****斜体+粗体*** 效果如下: 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 123456789101112* * *********- - -世界你好---------------------------------------* 世界你好 反斜杠可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 标签），你可以在星号的前面加上反斜杠： 12\\*literal asterisks\\* *literal asterisks* 图片与链接图片123![命名](图片链接)比如:![字体](http://oxv4ynhvc.bkt.clouddn.com/MKFont.png) 链接123[链接显示文字](链接地址)比如:[博客](http://taodongbo.cn) 博客地址: 博客 列表无序12345* **加粗**举个例子* 被星星包围的加醋**加粗**- **减号**一样的效果+ **加号**一样的效果 效果如下 有序1234561.文本2.标题3.图片 引用12&gt; 噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之 效果如下: 代码引用一句代码与多句的区别在于 ` 还是 3个` 一句代码12`[self.view addSubView:label]` 一段代码 展示效果分别如下: 表格123456|默认|居中|左对齐|右对齐||--|:-:|:-|-:||测试换行\\n不支持换行|测试1|测试2|测试3||*斜体*|**粗体**|***斜体+粗体***|正常||# 不可放标题|[可放链接](taodongbo.cn)|![可放图片](http://oxv4ynhvc.bkt.clouddn.com/MKYY.png)|`可放代码 hello word ` 以上是一些基本的用法，更多参考语法说明","categories":[{"name":"工具推荐","slug":"工具推荐","permalink":"http://taodongbo.cn/categories/工具推荐/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://taodongbo.cn/tags/工具/"},{"name":"Markdown","slug":"Markdown","permalink":"http://taodongbo.cn/tags/Markdown/"}]}]}